import { ControllerGenerator } from '../ControllerGenerator';
import { rainbow, raining, thunderStruck } from '../animation/animationLibrary'
import { BaseController } from '../BaseController';
import { ICompleteDevice } from '..';
import { AnimationManager } from '../animation/animationManager';
const controllerGenerator = new ControllerGenerator();

let onlineDevices;


async function generateControllers() {
    const completedDevices: ICompleteDevice[] = await controllerGenerator.discoverCompleteDevices().catch(e => { console.log(e) }) as ICompleteDevice[];
    const basecontrollers = controllerGenerator.generateControllers(completedDevices);

    //uses controllers generated by another controllerCreation.spec.ts file
    onlineDevices = basecontrollers.filter((controller: BaseController) => {
        return true;
        // return controller.getCachedDeviceInformation().protoDevice.uniqueId == 'DC4F22CF7C31'
        // return controller.getCachedDeviceInformation().protoDevice.uniqueId == '2CF432B7D7C5'
    })

}






describe('Test the animationManager class', function () {
    afterEach(done => {
        setTimeout(done, 100);
    });

    it('Should retrieve meta-data on each device', async function () {
        try {
            await generateControllers();
            const lights = [];

            for (const controller of onlineDevices) {
                controller.appendAnimationList(['thunderStruck', 'raining'])
                lights.push(controller);
            }
            // console.log(lights);
            const animationBlueprints = [thunderStruck, raining];
            const animationManager = new AnimationManager(lights, animationBlueprints);
            animationManager.generateAnimationLoopFromBlueprint(thunderStruck);
            animationManager.generateAnimationLoopFromBlueprint(raining);
            animationManager.startTicks();

        } catch (error) {
            console.log(error)
        }
    })
});